<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE scripts PUBLIC "-//UniTime//DTD University Course Timetabling/EN" "http://www.unitime.org/interface/Script.dtd">

<!--
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 *
 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 -->

<scripts created="Tue Oct 20 15:00 CEST 2015">
<script name="Batch Student Scheduling: Data Import" permission="Student Sectioning Solver" engine="python" created="Wed Oct 28 10:09:21 EDT 2015">
  <description><![CDATA[<h3>Import student course requests from the given CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, PIN, Course1, Course2, .... 
<li>PIN column is optional, make sure PIN Included toggle is set accordingly
</ul>
<b>Parameters:</b><ul>
<li>Input File: CSV file in the above format
<li>PIN Included: set to true if the input file contains PIN column
<li>Status: student status to be set (if selected)
<li>Trim Leading Zeros: trim leading zeros from the PUID
<li>Clear Existing Demands: replace existing student course demands with the given demands
<li>Create Limit Overrides: create limit override reservations for the imported students
<li>Name Columns: number of columns with student name
</ul>]]></description>
  <parameter name="clear" label="Clear Existing Demands" type="boolean" default="false"/>
  <parameter name="override" label="Create Limit Overrides" type="boolean" default="false"/>
  <parameter name="statusRef" label="Status" type="reference(StudentSectioningStatus)"/>
  <parameter name="pinIncluded" label="PIN Included" type="boolean" default="false"/>
  <parameter name="trimLeadingZeros" label="Trim Leading Zeros" type="boolean" default="true"/>
  <parameter name="file" label="Input File (CSV)" type="file"/>
  <parameter name="nameColumns" label="Name Columns" type="enum(0,1,2,3)" default="2"/>
  <body><![CDATA[import csv
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.model import UserData, StudentSectioningStatus, CourseDemand, CourseRequest, OverrideReservation, StudentSectioningQueue
from org.unitime.timetable.onlinesectioning.updates import ReloadStudent
from java.util import HashSet, Date
from java.lang import Long

def isOverrideNeeded(offering):
    for config in offering.getInstrOfferingConfigs():
        canEnroll = True
        for subpart in config.getSchedulingSubparts():
            hasEnabledClazz = False
            for clazz in subpart.getClasses():
                if clazz.isEnabledForStudentScheduling():
                    hasEnabledClazz = True
                    break
            if not hasEnabledClazz:
                canEnroll = False
                break
        if canEnroll: return False
    return True

def getStudent(puid, name, clear):
    student = hibSession.createQuery("from Student where session = :session and externalUniqueId = :puid"
        ).setLong("session", session.getUniqueId()).setString("puid", puid).uniqueResult()
    if not student:
        log.warn("Student %s (%s) does not exist." % (name, puid))
        return None
    log.info("%s %s" % (student.getExternalUniqueId(), student.getName("last-first-middle")))
    if clear:
        offerings = HashSet()
        for cd in student.getCourseDemands():
            if cd.getFreeTime():
                hibSession.delete(cd.getFreeTime())
            for cr in cd.getCourseRequests():
                offerings.add(cr.getCourseOffering().getInstructionalOffering())
                hibSession.delete(cr)
            hibSession.delete(cd)
        student.getCourseDemands().clear()
        for enrl in student.getClassEnrollments():
            hibSession.delete(enrl)
        student.getClassEnrollments().clear()
        if override:
            for offering in offerings:
                reservation = hibSession.createQuery(
                    "from OverrideReservation r where r.instructionalOffering = :offeringId and r.type = 1 and r.configurations is empty and r.classes is empty"
                    ).setLong("offeringId", offering.getUniqueId()).setMaxResults(1).uniqueResult()
                if reservation:
                    reservation.getStudents().remove(student)
                    if reservation.getStudents().isEmpty(): hibSession.delete(reservation)
                    else: hibSession.saveOrUpdate(reservation)
    return student


def setPin(student, pin):
    UserData.setProperty(student.getExternalUniqueId(), "PIN[%d]" % session.getUniqueId(), pin)

def addCourse(student, cn, ts, offeringIds):
    if not cn:
        log.debug("Empty slot skipped.")
        return
    course = hibSession.createQuery("from CourseOffering where subjectArea.session = :session and subjectAreaAbbv || ' ' || courseNbr = :name"
        ).setLong("session", session.getUniqueId()).setString("name", cn).uniqueResult()
    if not course:
        log.warn("Course %s does not exist." % cn)
        return
    log.debug(course.getCourseNameWithTitle())
    priority = 0
    for cd in student.getCourseDemands():
        if priority <= cd.getPriority() and not cd.isAlternative(): priority = cd.getPriority() + 1
        for cr in cd.getCourseRequests():
            if course == cr.getCourseOffering():
                log.warn("-- course is already requested")
                return False
    cd = CourseDemand()
    cd.setCourseRequests(HashSet())
    cd.setStudent(student)
    student.getCourseDemands().add(cd)
    cd.setAlternative(False)
    cd.setPriority(priority)
    cd.setWaitlist(False)
    cd.setTimestamp(ts)
    cr = CourseRequest()
    cd.getCourseRequests().add(cr)
    cr.setCourseDemand(cd)
    cr.setAllowOverlap(False)
    cr.setCredit(0)
    cr.setOrder(0)
    cr.setCourseOffering(course)
    if override and isOverrideNeeded(course.getInstructionalOffering()):
        log.debug("-- creating override for %s" % course.getCourseName())
        reservation = hibSession.createQuery(
            "from OverrideReservation r where r.instructionalOffering = :offeringId and r.type = 1 and r.configurations is empty and r.classes is empty"
            ).setLong("offeringId", course.getInstructionalOffering().getUniqueId()).setMaxResults(1).uniqueResult()
        if not reservation:
            reservation = OverrideReservation()
            reservation.setType(1)
            reservation.setInstructionalOffering(course.getInstructionalOffering())
            reservation.setClasses(HashSet())
            reservation.setConfigurations(HashSet())
            reservation.setStudents(HashSet())
            offeringIds.add(Long(course.getInstructionalOffering().getUniqueId()))
        reservation.getStudents().add(student)
        hibSession.saveOrUpdate(reservation)
    return True

def setStatus(student, status):
    student.setSectioningStatus(status)

def getOnlineServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getOnlineStudentSchedulingContainer()
    server = container.getSolver(str(session.getUniqueId()))
    return server

def execute():
    lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')
    status = None
    if statusRef:
        status = StudentSectioningStatus.getStatus(statusRef, session.getUniqueId(), hibSession)
        log.info("Using status %s - %s" % (status.getReference(), status.getLabel()))
    ts = Date()
    studentIds = HashSet()
    offeringIds = HashSet()
    for line in lines:
        if not line: continue
        if line[0].lower() == 'puid': continue
        puid = line[0]
        while trimLeadingZeros and puid[0] == '0': puid = puid[1:]
        name = None
        pin = None
        cstart = 1
        for i in range(0, int(nameColumns)):
            if name:
                name = "%s %s" % (name, line[cstart].strip())
            else:
                name = line[cstart].strip()
            cstart = cstart + 1
        if pinIncluded:
            pin = line[cstart]
            cstart = cstart + 1
        student = getStudent(puid, name, clear)
        if not student: continue
        if pin: setPin(student, pin)
        for course in line[cstart:]:
            addCourse(student, course, ts, offeringIds)
        if status:
            setStatus(student, status)
        studentIds.add(Long(student.getUniqueId()))
        hibSession.saveOrUpdate(student)

    StudentSectioningQueue.studentChanged(hibSession, None, session.getUniqueId(), studentIds)

    if offeringIds.size() > 0:
        StudentSectioningQueue.offeringChanged(hibSession, None, session.getUniqueId(), offeringIds)

    offeringIds

if not file:
    log.error("No input file was provided.")
else:
    execute()]]></body>
</script>
<script name="Batch Student Scheduling: Data Export [Class Enrollments]" permission="Student Sectioning Solver" engine="python" created="Thu Apr 28 02:00:42 EDT 2016">
  <description><![CDATA[<h3>Export student class enrollments into a CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, PIN, CRN1, CRN2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Status: students of this status will be exported
<li>Add Leading Zeros: add leading zeros to the PUID
<li>Default PIN: default PIN number to be used in the enrollment
</ul>]]></description>
  <parameter name="defaultPin" label="Default PIN" type="string"/>
  <parameter name="status" label="Status" type="reference(StudentSectioningStatus)"/>
  <parameter name="zeros" label="Add Leading Zeros" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import UserData

def getPin(student):
    pin = UserData.getProperty(student.getExternalUniqueId(), "PIN[%d]" % session.getUniqueId())
    if pin: return pin
    return defaultPin

def getStudent(student):
    puid = student.getExternalUniqueId()
    if zeros: puid = puid.zfill(9)
    log.info("%s %s" % (puid, student.getName("last-first-middle")))
    line = [puid, student.getName("last-first-middle"), getPin(student)]
    crns = {}
    for enrl in student.getClassEnrollments():
        crns[enrl.getClazz().getExternalId(enrl.getCourseOffering())] = True
    line.extend(sorted(crns.keys()))
    log.debug('-- %s' % ','.join(sorted(crns.keys())))
    return line

def execute():
    students = hibSession.createQuery("from Student where session = :session and sectioningStatus.reference = :status"
        ).setLong("session", session.getUniqueId()).setString("status", status).list()
    
    file = open(log.createOutput('%s_enrollments' % status,'csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','PIN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN'])
    for student in students:
        writer.writerow(getStudent(student))
    writer.writerow(['EOF'])
    file.close()

if not status:
    log.error("No student status was provided.")
else:
    execute()]]></body>
</script>
<script name="Batch Student Scheduling: Data Export [Courses]" permission="Student Sectioning Solver" engine="python" created="Thu Apr 28 02:00:34 EDT 2016">
  <description><![CDATA[<h3>Export student course demands into a CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, PIN, Course1, Course2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Status: students of this status will be exported
<li>Add Leading Zeros: add leading zeros to the PUID
<li>Default PIN: default PIN number to be used in the enrollment
</ul>]]></description>
  <parameter name="defaultPin" label="Default PIN" type="string"/>
  <parameter name="status" label="Status" type="reference(StudentSectioningStatus)"/>
  <parameter name="zeros" label="Add Leading Zeros" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import UserData

def getPin(student):
    pin = UserData.getProperty(student.getExternalUniqueId(), "PIN[%d]" % session.getUniqueId())
    if pin: return pin
    return defaultPin

def getStudent(student):
    puid = student.getExternalUniqueId()
    if zeros: puid = puid.zfill(9)
    log.info("%s %s" % (puid, student.getName("last-first-middle")))
    line = [puid, student.getName("last-first-middle"), getPin(student)]
    courses = {}
    for enrl in student.getClassEnrollments():
        courses[enrl.getCourseOffering().getCourseName()] = True
    for cd in student.getCourseDemands():
        if cd.isAlternative(): continue
        for cr in cd.getCourseRequests():
            if cr.getOrder() == 0:
                courses[cr.getCourseOffering().getCourseName()] = True
    line.extend(sorted(courses.keys()))
    log.debug('-- %s' % ','.join(sorted(courses.keys())))
    return line

def execute():
    students = hibSession.createQuery("from Student where session = :session and sectioningStatus.reference = :status"
        ).setLong("session", session.getUniqueId()).setString("status", status).list()
    
    file = open(log.createOutput('%s_courses' % status,'csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','Course','Course','Course','Course'])
    for student in students:
        writer.writerow(getStudent(student))
    writer.writerow(['EOF'])
    file.close()

if not status:
    log.error("No student status was provided.")
else:
    execute()]]></body>
</script>
<script name="Batch Student Scheduling: Solver Enroll" permission="Student Sectioning Solver" engine="python" created="Tue Oct 20 09:00:07 EDT 2015">
  <description><![CDATA[<h3>Used the batch student scheduling solver solution to enroll students on the online student scheduling server.</h3>
For each student that is loaded in the solver, the appropriate Enroll action is created and executed on the online student scheduling server.<br>
<b>Output is returned in the following CSV format:</b><ul>
<li>There is a line for each student class enrollment
<li>PUID, Name, PIN, Course, CRN, Result, Error Message
</ul>
<b>Parameters:</b><ul>
<li>Default PIN: default PIN number to be used in the enrollment
</ul>]]></description>
  <parameter name="defaultPin" label="Default PIN" type="string"/>
  <body><![CDATA[import csv
from java.util import ArrayList, HashSet
from java.lang import Long
from org.unitime.timetable.model import UserData
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.onlinesectioning.match import AnyStudentMatcher
from org.unitime.timetable.onlinesectioning.model import XCourseRequest
from org.unitime.timetable.onlinesectioning.basic import GetRequest, GetAssignment
from org.unitime.timetable.onlinesectioning.updates import EnrollStudent
from org.unitime.timetable.onlinesectioning.custom import RequestStudentUpdates
from org.unitime.timetable.onlinesectioning import OnlineSectioningLog
from org.unitime.timetable.gwt.shared import SectioningException

def getBatchServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getStudentSolverContainer()
    server = container.getSolver(log.getOwnerId())
    return server

def getOnlineServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getOnlineStudentSchedulingContainer()
    server = container.getSolver(str(session.getUniqueId()))
    return server

def getStudents(server):
    m = AnyStudentMatcher()
    m.setServer(server)
    return server.findStudents(m)

def getPin(student):
    pin = UserData.getProperty(student.getExternalId(), "PIN[%d]" % session.getUniqueId())
    if pin: return pin
    return defaultPin

def getUser(student):
    user = OnlineSectioningLog.Entity.newBuilder()
    user.setExternalId(log.getOwnerId())
    user.setName(log.getOwnerName())
    user.setType(OnlineSectioningLog.Entity.EntityType.MANAGER)
    if student:
        pin = getPin(student)
        if pin: user.addParameterBuilder().setKey("pin").setValue(pin)
    return user.build()

def generateAction(server, student):
    log.info("%s %s" % (student.getExternalId(), student.getName()))
    action = EnrollStudent()
    action.forStudent(student.getStudentId())
    
    request = server.execute(GetRequest().forStudent(student.getStudentId()), getUser(student))
    action.withRequest(request)

    enrollment = server.execute(GetAssignment().forStudent(student.getStudentId()), getUser(student))
    assignments = ArrayList()
    for course in enrollment.getCourseAssignments():
        if course.isFreeTime(): continue
        assignments.addAll(course.getClassAssignments())
    action.withAssignment(assignments)
    
    return action

def failStudent(server, action, student, writer, message):
    for assignment in action.getAssignment():
        course = server.getCourse(assignment.getCourseId())
        offering = server.getOffering(course.getOfferingId())
        section = offering.getSection(assignment.getClassId())
        writer.writerow([
            student.getExternalId(), student.getName(), getPin(student),
            course.getCourseName(), section.getExternalId(assignment.getCourseId()),
            'Failed', message
            ])

def executeAction(server, action, student, writer):
    if not action: return False
    enrollment = None
    try:
        enrollment = server.execute(action, getUser(student))
    except SectioningException, e:
        log.error('Enrollment failed: %s' % e.getMessage())
        failStudent(server, action, student, writer, e.getMessage())
        # writer.writerow([ student.getExternalId(), student.getName(), getPin(student), None, None, 'Failed', e.getMessage() ])
        return False
    for course in enrollment.getCourseAssignments():
        if course.isFreeTime(): continue
        sections = HashSet()
        for clazz in course.getClassAssignments():
            if not sections.add(clazz.getSection()): continue
            line = [ student.getExternalId(), student.getName(), getPin(student), '%s %s' % (course.getSubject(), course.getCourseNbr()), clazz.getSection() ]
            if clazz.isSaved(): line.append('Enrolled')
            else: line.append('Not Enrolled')
            if clazz.hasError():
                line.append(clazz.getError())
            if clazz.hasError():
                log.warn('%s %s %s: %s (%s)' % (course.getSubject(), course.getCourseNbr(), clazz.getSection(), clazz.getError(), line[5]))
            else:
                log.debug('%s %s %s' % (course.getSubject(), course.getCourseNbr(), clazz.getSection()))
            writer.writerow(line)
    return True

def execute(batch, online):
    file = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','PIN','Course','CRN','Status','Message'])
    failed = ArrayList()
    for student in getStudents(batch):
        if not executeAction(online, generateAction(batch, student), student, writer):
            failed.add(Long(student.getStudentId()))
    writer.writerow(['EOF'])
    file.close()
    if failed.size() > 0:
        req = RequestStudentUpdates()
        req.forStudents(failed)
        online.execute(req, getUser(None))

batch = getBatchServer()
online = getOnlineServer()
if not batch:
    log.error("Batch student scheduling solver is not loaded in.")
elif batch.isRunning():
    log.error("Batch student scheduling solver is running.")
elif batch.isWorking():
    log.error("Batch student scheduling solver is working.")
elif not online:
    log.error("Online student scheduling solver is not running.")
else:
    execute(batch, online)]]></body>
</script>
<script name="Batch Student Scheduling: Solver Export" permission="Student Sectioning Solver" engine="python" created="Tue Oct 20 09:00:14 EDT 2015">
  <description><![CDATA[<h3>Export batch student scheduling solver student class enrollments data into a CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, PIN, CRN1, CRN2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Add Leading Zeros: add leading zeros to the PUID
<li>Default PIN: default PIN number to be used in the enrollment
</ul>]]></description>
  <parameter name="defaultPin" label="Default PIN" type="string"/>
  <parameter name="zeros" label="Add Leading Zeros" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import UserData
from org.unitime.timetable.model.dao import Class_DAO, CourseOfferingDAO
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.onlinesectioning.match import AnyStudentMatcher
from org.unitime.timetable.onlinesectioning.model import XCourseRequest

def getServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getStudentSolverContainer()
    server = container.getSolver(log.getOwnerId())
    return server

def getStudents(server):
    m = AnyStudentMatcher()
    m.setServer(server)
    return server.findStudents(m)

def getPin(student):
    pin = UserData.getProperty(student.getExternalId(), "PIN[%d]" % session.getUniqueId())
    if pin: return pin
    return defaultPin

def generateRow(server, student):
    puid = student.getExternalId()
    if zeros: puid = puid.zfill(9)
    name = student.getName()
    log.info("%s %s" % (puid, name))
    line = [puid, name, getPin(student)]
    crns = {}
    for req in server.getStudent(student.getStudentId()).getRequests():
        if not isinstance(req, XCourseRequest): continue
        enrl = req.getEnrollment()
        if not enrl: continue
        course = hibSession.createQuery("from CourseOffering where uniqueId = :id").setLong("id", enrl.getCourseId()).uniqueResult()
        for id in enrl.getSectionIds():
            clazz = hibSession.createQuery("from Class_ where uniqueId = :id").setLong("id", id).uniqueResult()
            crns[clazz.getExternalId(course)] = True
    line.extend(sorted(crns.keys()))
    log.debug('-- %s' % ','.join(sorted(crns.keys())))
    return line

def execute(server):
    file = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','PIN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN'])
    for student in getStudents(server):
        writer.writerow(generateRow(server, student))
    writer.writerow(['EOF'])
    file.close()

server = getServer()
if not server:
    log.error("Batch student scheduling solver is not loaded in.")
elif server.isRunning():
    log.error("Batch student scheduling solver is running.")
elif server.isWorking():
    log.error("Batch student scheduling solver is working.")
else:
    execute(server)]]></body>
</script>
<script name="Batch Student Scheduling: Solver Enroll [XE Experiment]" permission="Student Sectioning Solver" engine="python" created="Thu Apr 28 03:14:26 EDT 2016">
  <description><![CDATA[<h3>Use the batch student scheduling solver solution and the XE Student API to push the enrollments to Banner.</h3>
For each student that is loaded in the solver, the appropriate registration message is created and passed on the Student API.<br>
<b>Output is returned in the following CSV format:</b><ul>
<li>There is a line for each student class enrollment
<li>PUID, Name, PIN, Course, CRN, Result, Error Message
</ul>
<b>Parameters:</b><ul>
<li>Admin Parameter: change to <b>systemIn</b> when Student API 9.5 is used
</ul>]]></description>
  <parameter name="persona" label="Admin Parameter" type="text" default="persona"/>
  <body><![CDATA[import csv
from java.lang import Long
from java.util import ArrayList, HashSet
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.restlet import Client
from org.restlet.data import Protocol, ChallengeScheme, MediaType
from org.restlet.resource import ClientResource, ResourceException
from org.unitime.timetable.onlinesectioning import AcademicSessionInfo
from org.unitime.banner.onlinesectioning import BannerTermProvider
from org.unitime.timetable import ApplicationProperties
from com.google.gson import Gson, GsonBuilder
from org.unitime.timetable.onlinesectioning.custom.purdue import GsonRepresentation, XEInterface
from org.unitime.timetable.gwt.shared import SectioningException
from org.unitime.timetable.onlinesectioning.match import AnyStudentMatcher
from org.unitime.timetable.onlinesectioning.custom import RequestStudentUpdates
from org.unitime.timetable.onlinesectioning.basic import GetRequest, GetAssignment
from org.unitime.timetable.onlinesectioning.updates import EnrollStudent
from org.unitime.timetable.onlinesectioning import OnlineSectioningLog
from org.unitime.timetable.model.dao import CourseOfferingDAO, Class_DAO

def getBatchServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getStudentSolverContainer()
    server = container.getSolver(log.getOwnerId())
    return server

def getOnlineServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getOnlineStudentSchedulingContainer()
    server = container.getSolver(str(session.getUniqueId()))
    return server


def getGson():
    builder = GsonBuilder()
    builder.setPrettyPrinting()
    return builder.create()

def getClient():
    protocols = ArrayList()
    protocols.add(Protocol.HTTP)
    protocols.add(Protocol.HTTPS)
    return Client(protocols)

def getResource(client):
    resource = ClientResource(ApplicationProperties.getProperty("banner.xe.site"))
    resource.setNext(client)
    resource.setChallengeResponse(ChallengeScheme.HTTP_BASIC, ApplicationProperties.getProperty("banner.xe.admin.user"), ApplicationProperties.getProperty("banner.xe.admin.password"))
    return resource

def getBannerId(student):
    return student.getExternalId().zfill(9)

def getStudents(server):
    m = AnyStudentMatcher()
    m.setServer(server)
    return server.findStudents(m)

def generateAction(server, student):
    log.info("%s %s" % (student.getExternalId(), student.getName()))
    action = EnrollStudent()
    action.forStudent(student.getStudentId())
    
    request = server.execute(GetRequest().forStudent(student.getStudentId()), getUser())
    action.withRequest(request)

    enrollment = server.execute(GetAssignment().forStudent(student.getStudentId()), getUser())
    assignments = ArrayList()
    for course in enrollment.getCourseAssignments():
        if course.isFreeTime(): continue
        assignments.addAll(course.getClassAssignments())
    action.withAssignment(assignments)
    
    return action

def enroll(client, student, action, writer):
    resource = getResource(client)

    info = AcademicSessionInfo(session)
    bt = BannerTermProvider()
    term = bt.getExternalTerm(info)
    campus = bt.getExternalCampus(info)
    
    gson = getGson()
    
    resource.addQueryParameter("term", term)
    resource.addQueryParameter("bannerId", getBannerId(student))
    resource.addQueryParameter(persona, "SB")
    try:
        resource.get(MediaType.APPLICATION_JSON)
    except ResourceException, e:
        response = GsonRepresentation(resource.getResponseEntity(), XEInterface.ErrorResponse).getObject()
        error = response.getError()
        if error and error.message:            
            raise SectioningException(error.message)
        if error and error.description:
            raise SectioningException(error.description)
        if error and error.errorMessage:
            raise SectioningException(error.errorMessage)
        raise SectioningException(e.getMessage())
    
    current = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse.TYPE_LIST).getObject()
    original = None
    if current and not current.isEmpty():
        original = current.get(0)
        #log.debug("Current registration: %s" % gson.toJson(original))
    
    if not original or not original.validStudent:
        reason = None
        if original and original.failureReasons:
            for m in original.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
        if reason: raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")
    
    noadd = HashSet()
    nodrop = HashSet()
    notregistered = HashSet()
    registered = {}
    if original.registrations:
        for reg in original.registrations:
            if reg.isRegistered():
                registered[reg.courseReferenceNumber] = reg
                if not reg.canDrop(True):
                    nodrop.add(reg.courseReferenceNumber)
            else:
                notregistered.add(reg.courseReferenceNumber)
                if not reg.canAdd(True):
                    noadd.add(reg.courseReferenceNumber)
    
    added = HashSet()
    req = XEInterface.RegisterRequest(term, getBannerId(student), None, True)
    for assignment in action.getAssignment():
        id = assignment.getSection()
        if not id in registered and noadd.contains(id):
            writer.writerow([
                student.getExternalId(), student.getName(),
                '%s %s' % (assignment.getSubject(), assignment.getCourseNbr()), id,
                'Failed', 'Action RE is not allowed.'
            ])
        else:
            if id in registered:
                if added.add(id): req.keep(id)
            else:
                if added.add(id): req.add(id, notregistered.contains(id))
    for id in registered.keys():
        if added.contains(id): continue
        reg = registered[id]
        if not campus == reg.campus:
            if added.add(id): req.keep(id)
        elif nodrop.contains(id):
            writer.writerow([
                student.getExternalId(), student.getName(),
                '%s %s' % (reg.subject, reg.courseNumber), id,
                'Failed', 'Action DDD is not allowed.'
            ])
            if added.add(id): req.keep(id)
        else:
            req.drop(id)
    
    #log.debug("Request: %s" % gson.toJson(req))
    
    try:
        resource.post(GsonRepresentation(req))
    except ResourceException, e:
        response = GsonRepresentation(resource.getResponseEntity(), XEInterface.ErrorResponse).getObject()
        error = response.getError()
        if error and error.message:            
            raise SectioningException(error.message)
        if error and error.description:
            raise SectioningException(error.description)
        if error and error.errorMessage:
            raise SectioningException(error.errorMessage)
        raise SectioningException(e.getMessage())
    
    response = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse).getObject()
    #log.debug("Response: %s" % gson.toJson(response))

    if not response:
        raise SectioningException("Failed to enroll student.")
    elif not response.validStudent:
        reason = None
        if response.failureReasons:
            for m in response.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
                raise SectioningException(reason)
        raise SectioningException("Failed to enroll student.")
    
    checked = HashSet()
    if response.registrations:
        for reg in response.registrations:
            id = reg.courseReferenceNumber
            checked.add(id)
            op = None
            if added.contains(id): op = "Add"
            else: op = "Drop"
            error = None
            if reg.crnErrors:
                for e in reg.crnErrors:
                    if not error:
                        error = e.message
                    else:
                        error = "%s\n%s" % (error, e.message)
            writer.writerow([
                student.getExternalId(), student.getName(),
                '%s %s' % (reg.subject, reg.courseNumber), id,
                op, reg.statusDescription, error
            ])
    
    ex = False
    for assignment in action.getAssignment():
        id = assignment.getSection()
        if checked.contains(id): continue
        op = None
        if added.contains(id): op = "Add"
        else: op = "Drop"
        ex = True
        writer.writerow([
            student.getExternalId(), student.getName(),
            '%s %s' % (assignment.getSubject(), assignment.getCourseNbr()), id,
            op, 'Exception', response.registrationException])
        
    if response.registrationException and not ex:
        writer.writerow([
            student.getExternalId(), student.getName(),
            None, None,
            None, 'Exception', response.registrationException])
    
    resource.release()
    

def getUser():
    user = OnlineSectioningLog.Entity.newBuilder()
    user.setExternalId(log.getOwnerId())
    user.setName(log.getOwnerName())
    user.setType(OnlineSectioningLog.Entity.EntityType.MANAGER)
    return user.build()

def failStudent(server, action, student, writer, message):
    for assignment in action.getAssignment():
        course = CourseOfferingDAO.getInstance().get(Long(assignment.getCourseId()))
        clazz = Class_DAO.getInstance().get(Long(assignment.getClassId()))
        if course and clazz:
            writer.writerow([
                student.getExternalId(), student.getName(),
                course.getCourseName(), clazz.getExternalId(course), 'Add', 'Failed', message
                ])
        else:
            writer.writerow([
                student.getExternalId(), student.getName(),
                str(assignment.getCourseId()), str(assignment.getClassId()), 'Add', 'Failed', message
                ])

def execute(batch, online):
    file = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','Course','CRN','Request','Status','Message'])
    client = getClient()
    ids = ArrayList()
    for student in getStudents(batch):
        ids.add(Long(student.getStudentId()))
        action = generateAction(batch, student)
        try:
            enroll(client, student, action, writer)
        except SectioningException, e:
            log.error('Enrollment failed: %s' % e.getMessage())
            failStudent(batch, action, student, writer, e.getMessage())
    writer.writerow(['EOF'])
    file.close()
    client.stop()
    #if ids.size() > 0:
    #    req = RequestStudentUpdates()
    #    req.forStudents(ids)
    #    online.execute(req, getUser())

batch = getBatchServer()
online = getOnlineServer()
if not batch:
    log.error("Batch student scheduling solver is not loaded in.")
elif batch.isRunning():
    log.error("Batch student scheduling solver is running.")
elif batch.isWorking():
    log.error("Batch student scheduling solver is working.")
elif not online:
    log.error("Online student scheduling solver is not running.")
else:
    execute(batch, online)]]></body>
</script>
</scripts>