<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE scripts PUBLIC "-//UniTime//DTD University Course Timetabling/EN" "http://www.unitime.org/interface/Script.dtd">

<!--
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 *
 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 -->

<scripts created="Tue Oct 20 15:00 CEST 2015">
<script name="Batch Student Scheduling: Data Import" permission="Student Sectioning Solver" engine="python" created="Wed Oct 28 10:09:21 EDT 2015">
  <description><![CDATA[<h3>Import student course requests from the given CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, PIN, Course1, Course2, .... 
<li>PIN column is optional, make sure PIN Included toggle is set accordingly
</ul>
<b>Parameters:</b><ul>
<li>Input File: CSV file in the above format
<li>PIN Included: set to true if the input file contains PIN column
<li>Status: student status to be set (if selected)
<li>Trim Leading Zeros: trim leading zeros from the PUID
<li>Clear Existing Demands: replace existing student course demands with the given demands
<li>Create Limit Overrides: create limit override reservations for the imported students
<li>Name Columns: number of columns with student name
</ul>]]></description>
  <parameter name="clear" label="Clear Existing Demands" type="boolean" default="false"/>
  <parameter name="override" label="Create Limit Overrides" type="boolean" default="false"/>
  <parameter name="statusRef" label="Status" type="reference(StudentSectioningStatus)"/>
  <parameter name="pinIncluded" label="PIN Included" type="boolean" default="false"/>
  <parameter name="trimLeadingZeros" label="Trim Leading Zeros" type="boolean" default="true"/>
  <parameter name="file" label="Input File (CSV)" type="file"/>
  <parameter name="nameColumns" label="Name Columns" type="enum(0,1,2,3)" default="2"/>
  <body><![CDATA[import csv
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.model import UserData, StudentSectioningStatus, CourseDemand, CourseRequest, OverrideReservation, StudentSectioningQueue
from org.unitime.timetable.onlinesectioning.updates import ReloadStudent
from java.util import HashSet, Date
from java.lang import Long

def isOverrideNeeded(offering):
    for config in offering.getInstrOfferingConfigs():
        canEnroll = True
        for subpart in config.getSchedulingSubparts():
            hasEnabledClazz = False
            for clazz in subpart.getClasses():
                if clazz.isEnabledForStudentScheduling():
                    hasEnabledClazz = True
                    break
            if not hasEnabledClazz:
                canEnroll = False
                break
        if canEnroll: return False
    return True

def getStudent(puid, name, clear):
    student = hibSession.createQuery("from Student where session = :session and externalUniqueId = :puid"
        ).setLong("session", session.getUniqueId()).setString("puid", puid).uniqueResult()
    if not student:
        log.warn("Student %s (%s) does not exist." % (name, puid))
        return None
    log.info("%s %s" % (student.getExternalUniqueId(), student.getName("last-first-middle")))
    if clear:
        offerings = HashSet()
        for cd in student.getCourseDemands():
            if cd.getFreeTime():
                hibSession.delete(cd.getFreeTime())
            for cr in cd.getCourseRequests():
                offerings.add(cr.getCourseOffering().getInstructionalOffering())
                hibSession.delete(cr)
            hibSession.delete(cd)
        student.getCourseDemands().clear()
        for enrl in student.getClassEnrollments():
            hibSession.delete(enrl)
        student.getClassEnrollments().clear()
        if override:
            for offering in offerings:
                reservation = hibSession.createQuery(
                    "from OverrideReservation r where r.instructionalOffering = :offeringId and r.type = 1 and r.configurations is empty and r.classes is empty"
                    ).setLong("offeringId", offering.getUniqueId()).setMaxResults(1).uniqueResult()
                if reservation:
                    reservation.getStudents().remove(student)
                    if reservation.getStudents().isEmpty(): hibSession.delete(reservation)
                    else: hibSession.saveOrUpdate(reservation)
    return student


def setPin(student, pin):
    UserData.setProperty(student.getExternalUniqueId(), "PIN[%d]" % session.getUniqueId(), pin)

def addCourse(student, cn, ts, offeringIds):
    if not cn:
        log.debug("Empty slot skipped.")
        return
    course = hibSession.createQuery("from CourseOffering where subjectArea.session = :session and subjectAreaAbbv || ' ' || courseNbr = :name"
        ).setLong("session", session.getUniqueId()).setString("name", cn).uniqueResult()
    if not course:
        log.warn("Course %s does not exist." % cn)
        return
    log.debug(course.getCourseNameWithTitle())
    priority = 0
    for cd in student.getCourseDemands():
        if priority <= cd.getPriority() and not cd.isAlternative(): priority = cd.getPriority() + 1
        for cr in cd.getCourseRequests():
            if course == cr.getCourseOffering():
                log.warn("-- course is already requested")
                return False
    cd = CourseDemand()
    cd.setCourseRequests(HashSet())
    cd.setStudent(student)
    student.getCourseDemands().add(cd)
    cd.setAlternative(False)
    cd.setPriority(priority)
    cd.setWaitlist(False)
    cd.setTimestamp(ts)
    cr = CourseRequest()
    cd.getCourseRequests().add(cr)
    cr.setCourseDemand(cd)
    cr.setAllowOverlap(False)
    cr.setCredit(0)
    cr.setOrder(0)
    cr.setCourseOffering(course)
    if override and isOverrideNeeded(course.getInstructionalOffering()):
        log.debug("-- creating override for %s" % course.getCourseName())
        reservation = hibSession.createQuery(
            "from OverrideReservation r where r.instructionalOffering = :offeringId and r.type = 1 and r.configurations is empty and r.classes is empty"
            ).setLong("offeringId", course.getInstructionalOffering().getUniqueId()).setMaxResults(1).uniqueResult()
        if not reservation:
            reservation = OverrideReservation()
            reservation.setType(1)
            reservation.setInstructionalOffering(course.getInstructionalOffering())
            reservation.setClasses(HashSet())
            reservation.setConfigurations(HashSet())
            reservation.setStudents(HashSet())
            offeringIds.add(Long(course.getInstructionalOffering().getUniqueId()))
        reservation.getStudents().add(student)
        hibSession.saveOrUpdate(reservation)
    return True

def setStatus(student, status):
    student.setSectioningStatus(status)

def getOnlineServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getOnlineStudentSchedulingContainer()
    server = container.getSolver(str(session.getUniqueId()))
    return server

def execute():
    lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')
    status = None
    if statusRef:
        status = StudentSectioningStatus.getStatus(statusRef, session.getUniqueId(), hibSession)
        log.info("Using status %s - %s" % (status.getReference(), status.getLabel()))
    ts = Date()
    studentIds = HashSet()
    offeringIds = HashSet()
    for line in lines:
        if not line: continue
        if line[0].lower() == 'puid': continue
        puid = line[0]
        while trimLeadingZeros and puid[0] == '0': puid = puid[1:]
        name = None
        pin = None
        cstart = 1
        for i in range(0, int(nameColumns)):
            if name:
                name = "%s %s" % (name, line[cstart].strip())
            else:
                name = line[cstart].strip()
            cstart = cstart + 1
        if pinIncluded:
            pin = line[cstart]
            cstart = cstart + 1
        student = getStudent(puid, name, clear)
        if not student: continue
        if pin: setPin(student, pin)
        for course in line[cstart:]:
            addCourse(student, course, ts, offeringIds)
        if status:
            setStatus(student, status)
        studentIds.add(Long(student.getUniqueId()))
        hibSession.saveOrUpdate(student)

    StudentSectioningQueue.studentChanged(hibSession, None, session.getUniqueId(), studentIds)

    if offeringIds.size() > 0:
        StudentSectioningQueue.offeringChanged(hibSession, None, session.getUniqueId(), offeringIds)

    offeringIds

if not file:
    log.error("No input file was provided.")
else:
    execute()]]></body>
</script>
<script name="Batch Student Scheduling: Data Export [Class Enrollments]" permission="Student Sectioning Solver" engine="python" created="Thu Apr 28 02:00:42 EDT 2016">
  <description><![CDATA[<h3>Export student class enrollments into a CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, PIN, CRN1, CRN2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Status: students of this status will be exported
<li>Add Leading Zeros: add leading zeros to the PUID
<li>Default PIN: default PIN number to be used in the enrollment
</ul>]]></description>
  <parameter name="defaultPin" label="Default PIN" type="string"/>
  <parameter name="status" label="Status" type="reference(StudentSectioningStatus)"/>
  <parameter name="zeros" label="Add Leading Zeros" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import UserData

def getPin(student):
    pin = UserData.getProperty(student.getExternalUniqueId(), "PIN[%d]" % session.getUniqueId())
    if pin: return pin
    return defaultPin

def getStudent(student):
    puid = student.getExternalUniqueId()
    if zeros: puid = puid.zfill(9)
    log.info("%s %s" % (puid, student.getName("last-first-middle")))
    line = [puid, student.getName("last-first-middle"), getPin(student)]
    crns = {}
    for enrl in student.getClassEnrollments():
        crns[enrl.getClazz().getExternalId(enrl.getCourseOffering())] = True
    line.extend(sorted(crns.keys()))
    log.debug('-- %s' % ','.join(sorted(crns.keys())))
    return line

def execute():
    students = hibSession.createQuery("from Student where session = :session and sectioningStatus.reference = :status"
        ).setLong("session", session.getUniqueId()).setString("status", status).list()
    
    file = open(log.createOutput('%s_enrollments' % status,'csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','PIN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN'])
    for student in students:
        writer.writerow(getStudent(student))
    writer.writerow(['EOF'])
    file.close()

if not status:
    log.error("No student status was provided.")
else:
    execute()]]></body>
</script>
<script name="Batch Student Scheduling: Data Export [Courses]" permission="Student Sectioning Solver" engine="python" created="Thu Apr 28 02:00:34 EDT 2016">
  <description><![CDATA[<h3>Export student course demands into a CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, PIN, Course1, Course2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Status: students of this status will be exported
<li>Add Leading Zeros: add leading zeros to the PUID
<li>Default PIN: default PIN number to be used in the enrollment
</ul>]]></description>
  <parameter name="defaultPin" label="Default PIN" type="string"/>
  <parameter name="status" label="Status" type="reference(StudentSectioningStatus)"/>
  <parameter name="zeros" label="Add Leading Zeros" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import UserData

def getPin(student):
    pin = UserData.getProperty(student.getExternalUniqueId(), "PIN[%d]" % session.getUniqueId())
    if pin: return pin
    return defaultPin

def getStudent(student):
    puid = student.getExternalUniqueId()
    if zeros: puid = puid.zfill(9)
    log.info("%s %s" % (puid, student.getName("last-first-middle")))
    line = [puid, student.getName("last-first-middle"), getPin(student)]
    courses = {}
    for enrl in student.getClassEnrollments():
        courses[enrl.getCourseOffering().getCourseName()] = True
    for cd in student.getCourseDemands():
        if cd.isAlternative(): continue
        for cr in cd.getCourseRequests():
            if cr.getOrder() == 0:
                courses[cr.getCourseOffering().getCourseName()] = True
    line.extend(sorted(courses.keys()))
    log.debug('-- %s' % ','.join(sorted(courses.keys())))
    return line

def execute():
    students = hibSession.createQuery("from Student where session = :session and sectioningStatus.reference = :status"
        ).setLong("session", session.getUniqueId()).setString("status", status).list()
    
    file = open(log.createOutput('%s_courses' % status,'csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','Course','Course','Course','Course'])
    for student in students:
        writer.writerow(getStudent(student))
    writer.writerow(['EOF'])
    file.close()

if not status:
    log.error("No student status was provided.")
else:
    execute()]]></body>
</script>
<script name="Batch Student Scheduling: Solver Enroll" permission="Student Sectioning Solver" engine="python" created="Tue Oct 20 09:00:07 EDT 2015">
  <description><![CDATA[<h3>Used the batch student scheduling solver solution to enroll students on the online student scheduling server.</h3>
For each student that is loaded in the solver, the appropriate Enroll action is created and executed on the online student scheduling server.<br>
<b>Output is returned in the following CSV format:</b><ul>
<li>There is a line for each student class enrollment
<li>PUID, Name, PIN, Course, CRN, Result, Error Message
</ul>
<b>Parameters:</b><ul>
<li>Default PIN: default PIN number to be used in the enrollment
</ul>]]></description>
  <parameter name="defaultPin" label="Default PIN" type="string"/>
  <body><![CDATA[import csv
from java.util import ArrayList, HashSet
from java.lang import Long
from org.unitime.timetable.model import UserData
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.onlinesectioning.match import AnyStudentMatcher
from org.unitime.timetable.onlinesectioning.model import XCourseRequest
from org.unitime.timetable.onlinesectioning.basic import GetRequest, GetAssignment
from org.unitime.timetable.onlinesectioning.updates import EnrollStudent
from org.unitime.timetable.onlinesectioning.custom import RequestStudentUpdates
from org.unitime.timetable.onlinesectioning import OnlineSectioningLog
from org.unitime.timetable.gwt.shared import SectioningException

def getBatchServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getStudentSolverContainer()
    server = container.getSolver(log.getOwnerId())
    return server

def getOnlineServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getOnlineStudentSchedulingContainer()
    server = container.getSolver(str(session.getUniqueId()))
    return server

def getStudents(server):
    m = AnyStudentMatcher()
    m.setServer(server)
    return server.findStudents(m)

def getPin(student):
    pin = UserData.getProperty(student.getExternalId(), "PIN[%d]" % session.getUniqueId())
    if pin: return pin
    return defaultPin

def getUser(student):
    user = OnlineSectioningLog.Entity.newBuilder()
    user.setExternalId(log.getOwnerId())
    user.setName(log.getOwnerName())
    user.setType(OnlineSectioningLog.Entity.EntityType.MANAGER)
    if student:
        pin = getPin(student)
        if pin: user.addParameterBuilder().setKey("pin").setValue(pin)
    return user.build()

def generateAction(server, student):
    log.info("%s %s" % (student.getExternalId(), student.getName()))
    action = EnrollStudent()
    action.forStudent(student.getStudentId())
    
    request = server.execute(GetRequest().forStudent(student.getStudentId()), getUser(student))
    action.withRequest(request)

    enrollment = server.execute(GetAssignment().forStudent(student.getStudentId()), getUser(student))
    assignments = ArrayList()
    for course in enrollment.getCourseAssignments():
        if course.isFreeTime(): continue
        assignments.addAll(course.getClassAssignments())
    action.withAssignment(assignments)
    
    return action

def failStudent(server, action, student, writer, message):
    for assignment in action.getAssignment():
        course = server.getCourse(assignment.getCourseId())
        offering = server.getOffering(course.getOfferingId())
        section = offering.getSection(assignment.getClassId())
        writer.writerow([
            student.getExternalId(), student.getName(), getPin(student),
            course.getCourseName(), section.getExternalId(assignment.getCourseId()),
            'Failed', message
            ])

def executeAction(server, action, student, writer):
    if not action: return False
    enrollment = None
    try:
        enrollment = server.execute(action, getUser(student))
    except SectioningException, e:
        log.error('Enrollment failed: %s' % e.getMessage())
        failStudent(server, action, student, writer, e.getMessage())
        # writer.writerow([ student.getExternalId(), student.getName(), getPin(student), None, None, 'Failed', e.getMessage() ])
        return False
    for course in enrollment.getCourseAssignments():
        if course.isFreeTime(): continue
        sections = HashSet()
        for clazz in course.getClassAssignments():
            if not sections.add(clazz.getSection()): continue
            line = [ student.getExternalId(), student.getName(), getPin(student), '%s %s' % (course.getSubject(), course.getCourseNbr()), clazz.getSection() ]
            if clazz.isSaved(): line.append('Enrolled')
            else: line.append('Not Enrolled')
            if clazz.hasError():
                line.append(clazz.getError())
            if clazz.hasError():
                log.warn('%s %s %s: %s (%s)' % (course.getSubject(), course.getCourseNbr(), clazz.getSection(), clazz.getError(), line[5]))
            else:
                log.debug('%s %s %s' % (course.getSubject(), course.getCourseNbr(), clazz.getSection()))
            writer.writerow(line)
    return True

def execute(batch, online):
    file = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','PIN','Course','CRN','Status','Message'])
    failed = ArrayList()
    for student in getStudents(batch):
        if not executeAction(online, generateAction(batch, student), student, writer):
            failed.add(Long(student.getStudentId()))
    writer.writerow(['EOF'])
    file.close()
    if failed.size() > 0:
        req = RequestStudentUpdates()
        req.forStudents(failed)
        online.execute(req, getUser(None))

batch = getBatchServer()
online = getOnlineServer()
if not batch:
    log.error("Batch student scheduling solver is not loaded in.")
elif batch.isRunning():
    log.error("Batch student scheduling solver is running.")
elif batch.isWorking():
    log.error("Batch student scheduling solver is working.")
elif not online:
    log.error("Online student scheduling solver is not running.")
else:
    execute(batch, online)]]></body>
</script>
<script name="Batch Student Scheduling: Solver Export" permission="Student Sectioning Solver" engine="python" created="Tue Oct 20 09:00:14 EDT 2015">
  <description><![CDATA[<h3>Export batch student scheduling solver student class enrollments data into a CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, PIN, CRN1, CRN2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Add Leading Zeros: add leading zeros to the PUID
<li>Default PIN: default PIN number to be used in the enrollment
</ul>]]></description>
  <parameter name="defaultPin" label="Default PIN" type="string"/>
  <parameter name="zeros" label="Add Leading Zeros" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import UserData
from org.unitime.timetable.model.dao import Class_DAO, CourseOfferingDAO
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.onlinesectioning.match import AnyStudentMatcher
from org.unitime.timetable.onlinesectioning.model import XCourseRequest

def getServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getStudentSolverContainer()
    server = container.getSolver(log.getOwnerId())
    return server

def getStudents(server):
    m = AnyStudentMatcher()
    m.setServer(server)
    return server.findStudents(m)

def getPin(student):
    pin = UserData.getProperty(student.getExternalId(), "PIN[%d]" % session.getUniqueId())
    if pin: return pin
    return defaultPin

def generateRow(server, student):
    puid = student.getExternalId()
    if zeros: puid = puid.zfill(9)
    name = student.getName()
    log.info("%s %s" % (puid, name))
    line = [puid, name, getPin(student)]
    crns = {}
    for req in server.getStudent(student.getStudentId()).getRequests():
        if not isinstance(req, XCourseRequest): continue
        enrl = req.getEnrollment()
        if not enrl: continue
        course = hibSession.createQuery("from CourseOffering where uniqueId = :id").setLong("id", enrl.getCourseId()).uniqueResult()
        for id in enrl.getSectionIds():
            clazz = hibSession.createQuery("from Class_ where uniqueId = :id").setLong("id", id).uniqueResult()
            crns[clazz.getExternalId(course)] = True
    line.extend(sorted(crns.keys()))
    log.debug('-- %s' % ','.join(sorted(crns.keys())))
    return line

def execute(server):
    file = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','PIN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN'])
    for student in getStudents(server):
        writer.writerow(generateRow(server, student))
    writer.writerow(['EOF'])
    file.close()

server = getServer()
if not server:
    log.error("Batch student scheduling solver is not loaded in.")
elif server.isRunning():
    log.error("Batch student scheduling solver is running.")
elif server.isWorking():
    log.error("Batch student scheduling solver is working.")
else:
    execute(server)]]></body>
</script>
<script name="Batch Student Scheduling: Solver Enroll [XE]" permission="Student Sectioning Solver" engine="python" created="Wed May 11 13:59:45 EDT 2016">
  <description><![CDATA[<h3>Enroll students from the batch studeht scheduling solver using the Banner XE API.</h3>
<p>Output is returned in the CSV format.<br>There is a line for each student class enrollment:<br>PUID, Name, Course, CRN, Request, Registration Status, Error Message, Used Override</p>
<p><b>Parameters:</b><ul>
<li>Name Columns: number of columns with student name
<li>Automatic Overrides: check to use automatic overrides
<li>Allowed Overrides: list of overrides that can be used (when enabled)
<li>Manual Overrides: list of overrides that are manually put in
<li>Conditional Add Drop: check if conditional add drop is to be enabled
<li>Hold Password: enter hold password if students with hold should be enrolled
<li>Registration Date: for back-dating enter registration date (in yyyy-mm-dd format)
</ul></p>]]></description>
  <parameter name="autoOverrides" label="1. Automatic Overrides" type="boolean" default="false"/>
  <parameter name="holdPassword" label="5. Hold Password" type="text"/>
  <parameter name="overrides" label="3. Manual Overrides" type="textarea" default="PUID,CRN,Override (one override per line)"/>
  <parameter name="registrationDate" label="6. Registration Date (yyyy-mm-dd)" type="text"/>
  <parameter name="allowedOverrides" label="2. Allowed Overrides" type="text" default="CAMPUS,CLASS,CLOSED,COLLEGE,CO-REQ,DEGREE,DPT-PERMIT,INST-PERMT,HONORS,DUP-CRSE,LEVEL,MAJOR,PRE-REQ,PROGRAM,TIME-CNFLT"/>
  <parameter name="conditionalAddDrop" label="4. Conditional Add Drop" type="boolean" default="true"/>
  <body><![CDATA[import csv
from xml.dom import minidom
from java.lang import Long
from java.util import ArrayList, HashSet, Date
from java.io import StringReader
from org.dom4j.io import SAXReader
from org.restlet import Client
from org.restlet.data import Protocol, ChallengeScheme, MediaType
from org.restlet.resource import ClientResource, ResourceException
from org.unitime.timetable import ApplicationProperties
from org.unitime.timetable.onlinesectioning import AcademicSessionInfo
from org.unitime.timetable.onlinesectioning.custom.purdue import GsonRepresentation, XEInterface
from org.unitime.timetable.gwt.shared import SectioningException
from org.unitime.banner.onlinesectioning import BannerTermProvider
from org.unitime.banner.model import BannerSession, QueueOut
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.onlinesectioning import OnlineSectioningLog
from org.unitime.timetable.onlinesectioning.basic import GetAssignment
from org.unitime.timetable.onlinesectioning.match import AnyStudentMatcher

def getClient():
    protocols = ArrayList()
    protocols.add(Protocol.HTTP)
    protocols.add(Protocol.HTTPS)
    return Client(protocols)

def getResource(client):
    resource = ClientResource(ApplicationProperties.getProperty("banner.xe.site"))
    resource.setNext(client)
    resource.setChallengeResponse(ChallengeScheme.HTTP_BASIC, ApplicationProperties.getProperty("banner.xe.admin.user"), ApplicationProperties.getProperty("banner.xe.admin.password"))
    return resource

def getCourseNameForCrn(crn):
    course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setString("crn", crn).setMaxResults(1).uniqueResult()
    if course:
        return course.getCourseName()
    return None

def getConsent(crn):
    return hibSession.createQuery(
        "select co.consentType.reference from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId"
        ).setLong("sessionId", session.getUniqueId()).setString("crn", crn).setMaxResults(1).uniqueResult()

def getDefaultOverride(crn, messageType):
    if messageType == 'DEPT' or messageType == 'SAPR':
        consent = getConsent(crn)
        if consent == "IN": return "INST-PERMT"
        elif consent == "DP": return "DPT-PERMIT"
        else: return "HONORS"
    elif messageType in defaultOverrides:
        return defaultOverrides[messageType]
    else:
        return None

def getManualOverride(puid, crn, manualOverrides):
    if not manualOverrides: return None
    for line in manualOverrides:
        if not line: continue
        if not line[0] or line[0].strip().zfill(9) == puid:
            if line[1] and line[1].strip() == crn:
                return line[2].strip()
    return None

def addOverride(req, id, override, overrides):
    for crn in req.courseReferenceNumbers:
        if crn.courseReferenceNumber == id:
            log.debug('Adding override %s for %s' % (override, id))
            crn.courseOverride = override
            if id not in overrides:
                overrides[id] = [override]
            else:
                overrides[id].append(override)
            return True
    log.warn('Failed to add override %s for %s' % (override, id))
    return False

def getOverride(req, id, overrides):
    if overrides and id in overrides:
        return ','.join(overrides[id])
    else:
        for crn in req.courseReferenceNumbers:
            if crn.courseReferenceNumber == id:
                return crn.courseOverride
    return None

def handleError(resource, e):
    error = None
    if resource.getResponseEntity():
        response = GsonRepresentation(resource.getResponseEntity(), XEInterface.ErrorResponse).getObject()
        if response: error = response.getError()
    if error and error.message:            
        raise SectioningException(error.message)
    if error and error.description:
        raise SectioningException(error.description)
    if error and error.errorMessage:
        raise SectioningException(error.errorMessage)
    raise SectioningException(e.getMessage())

def getSchedule(resource):
    try:
        resource.get(MediaType.APPLICATION_JSON)
    except ResourceException, e: handleError(resource, e)
    
    current = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse.TYPE_LIST).getObject()
    original = None
    if current and not current.isEmpty():
        original = current.get(0)
    
    if not original or not original.validStudent:
        reason = None
        if original and original.failureReasons:
            for m in original.failureReasons:
                if m == "Holds prevent registration." and holdPassword:
                    return getHoldSchedule(resource)
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
        if reason: raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")
    
    return original

def getHoldSchedule(resource):
    log.debug("Using hold password...")
    term = resource.getQueryValue("term")
    puid = resource.getQueryValue("bannerId")
    req = XEInterface.RegisterRequest(term, puid, None, True)
    req.empty()
    if holdPassword:
        req.holdPassword = holdPassword
    
    try:
        resource.post(GsonRepresentation(req))
    except ResourceException, e: handleError(resource, e)
    
    response = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse).getObject()
    
    if not response:
        raise SectioningException("Failed to check student registration status.")
    elif not response.validStudent:
        reason = None
        if response.failureReasons:
            for m in response.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
                raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")
    
    return response

def postChanges(resource, req):
    try:
        resource.post(GsonRepresentation(req))
    except ResourceException, e: handleError(resource, e)
    
    response = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse).getObject()
    
    if not response:
        raise SectioningException("Failed to enroll student.")
    elif not response.validStudent:
        reason = None
        if response.failureReasons:
            for m in response.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
                raise SectioningException(reason)
        raise SectioningException("Failed to enroll student.")

    return response

def enroll(client, puid, name, crns, writer, manualOverrides):
    log.info('%s: %s [%s]' % (puid, name, ','.join(crns)))
    resource = getResource(client)

    info = AcademicSessionInfo(session)
    bt = BannerTermProvider()
    term = bt.getExternalTerm(info)
    campus = bt.getExternalCampus(info)
    puid = puid.zfill(9)
    
    resource.addQueryParameter("term", term)
    resource.addQueryParameter("bannerId", puid)
    resource.addQueryParameter("systemIn", "SB")
    resource.addQueryParameter("persona", "SB")
    if holdPassword:
        resource.addQueryParameter("holdPassword", holdPassword)

    original = getSchedule(resource)
    
    noadd = HashSet()
    nodrop = HashSet()
    notregistered = HashSet()
    registered = {}
    if original.registrations:
        for reg in original.registrations:
            if reg.isRegistered():
                registered[reg.courseReferenceNumber] = reg
                if not reg.canDrop(True):
                    nodrop.add(reg.courseReferenceNumber)
            else:
                notregistered.add(reg.courseReferenceNumber)
                if not reg.canAdd(True):
                    noadd.add(reg.courseReferenceNumber)
    
    added = HashSet()
    req = XEInterface.RegisterRequest(term, puid, None, True)
    if holdPassword:
        req.holdPassword = holdPassword
    for id in crns:
        if not id: continue
        if not id in registered and noadd.contains(id):
            writer.writerow([
                puid, name,
                getCourseNameForCrn(id), id,
                'Failed', 'Action RE is not allowed.'
            ])
        else:
            if id in registered:
                if added.add(id): req.keep(id)
            else:
                if added.add(id): req.add(id, notregistered.contains(id))
    for id in registered.keys():
        if added.contains(id): continue
        reg = registered[id]
        if not campus == reg.campus:
            if added.add(id): req.keep(id)
        elif nodrop.contains(id):
            writer.writerow([
                puid, name,
                '%s %s' % (reg.subject, reg.courseNumber), id,
                'Failed', 'Action DDD is not allowed.'
            ])
            if added.add(id): req.keep(id)
        else:
            req.drop(id)
            
    appliedOverrides = {}
    for id in crns:
        override = getManualOverride(puid, id, manualOverrides)
        if override: addOverride(req, id, override, appliedOverrides)
    
    if registrationDate:
        req.registrationDate = registrationDate
    if conditionalAddDrop:
        req.conditionalAddDrop = "Y"

    response = postChanges(resource, req)
    
    while autoOverrides and response.registrations:
        changed = False
        for reg in response.registrations:
            id = reg.courseReferenceNumber
            if reg.crnErrors:
                for e in reg.crnErrors:
                    override = getDefaultOverride(id, e.messageType)
                    if override and (not allowedOverrides or override in allowedOverrides.split(',')):
                        if addOverride(req, id, override, appliedOverrides):
                            changed = True
                        break
        
        if not changed: break
        response = postChanges(resource, req)
    
    checked = HashSet()
    if response.registrations:
        for reg in response.registrations:
            id = reg.courseReferenceNumber
            checked.add(id)
            op = None
            if added.contains(id): op = "Add"
            else: op = "Drop"
            error = None
            errorType = []
            if reg.crnErrors:
                for e in reg.crnErrors:
                    if not error:
                        error = '%s: %s' % (e.messageType, e.message)
                    else:
                        error = "%s\n%s: %s" % (error, e.messageType, e.message)
            writer.writerow([
                puid, name,
                '%s %s' % (reg.subject, reg.courseNumber), id,
                op, reg.statusDescription, error, getOverride(req, id, appliedOverrides)
            ])
            if error: log.warn('%s: %s' % (id, error))
    
    ex = False
    for id in crns:
        if not id: continue
        if checked.contains(id): continue
        op = None
        if added.contains(id): op = "Add"
        else: op = "Drop"
        ex = True
        writer.writerow([
            puid, name,
            getCourseNameForCrn(id), id,
            op, 'Exception', response.registrationException])
        
    if response.registrationException and not ex:
        writer.writerow([
            puid, name,
            None, None,
            None, 'Exception', response.registrationException])
        
    if response.registrationException: log.warn(response.registrationException)
    
    resource.release()

def failStudent(puid, name, crns, writer, message):
    for id in crns:
        if not id: continue
        writer.writerow([puid, name, getCourseNameForCrn(id), id, 'Add', 'Failed', message])

def createStudentRequestUpdateMessage(puids):
    term = BannerTermProvider().getExternalTerm(AcademicSessionInfo(session))
    doc = minidom.getDOMImplementation().createDocument(None, "studentUpdateRequest", None)
    root = doc.documentElement
    for puid in puids:
        studentEl = doc.createElement("student")
        studentEl.setAttribute("externalId", puid.zfill(9))
        studentEl.setAttribute("session", term)
        root.appendChild(studentEl)
    return doc.toprettyxml()

def requestStudentUpdate(puids):
    log.info('Requesting student update...')
    message = createStudentRequestUpdateMessage(puids)
    out = QueueOut()
    out.setXml(SAXReader().read(StringReader(message)))
    out.setStatus(QueueOut.STATUS_READY)
    out.setPostDate(Date())
    hibSession.save(out)

defaultOverrides = {
    'CAMP': 'CAMPUS',
    'CLAS': 'CLASS',
    'CLOS': 'CLOSED',
    'COLL': 'COLLEGE',
    'CORQ': 'CO-REQ',
    'DEGR': 'DEGREE',
    'DEPT': 'DPT-PERMIT',
    'DUPL': 'DUP-CRSE',
    'LEVL': 'LEVEL',
    'MAJR': 'MAJOR',
    'PREQ': 'PRE-REQ',
    'PROG': 'PROGRAM',
    'TIME': 'TIME-CNFLT',
    }

def getBatchServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getStudentSolverContainer()
    server = container.getSolver(log.getOwnerId())
    return server

def getUser():
    user = OnlineSectioningLog.Entity.newBuilder()
    user.setExternalId(log.getOwnerId())
    user.setName(log.getOwnerName())
    user.setType(OnlineSectioningLog.Entity.EntityType.MANAGER)
    return user.build()

def getCrns(server, studentId):
    enrollment = server.execute(GetAssignment().forStudent(studentId), getUser())
    crns = {}
    for course in enrollment.getCourseAssignments():
        if course.isFreeTime(): continue
        for assignment in course.getClassAssignments():
            id = assignment.getSection()
            if id: crns[id] = True
    return sorted(crns.keys())

def getStudents(server):
    m = AnyStudentMatcher()
    m.setServer(server)
    return server.findStudents(m)

def execute(batch):
    manualOverrides = None
    if overrides:
        manualOverrides = []
        for line in csv.reader(overrides.split('\n'), delimiter=",", quotechar='"'):
            manualOverrides.append(line)
    output = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','Course','CRN','Request','Status','Message','Used Override'])
    client = getClient()
    puids = []
    for student in getStudents(batch):
        puid = student.getExternalId()
        name = student.getName()
        crns = getCrns(batch, student.getStudentId())
        puids.append(puid)
        try:
            enroll(client, puid, name, crns, writer, manualOverrides)
        except SectioningException, e:
            log.error('Enrollment failed: %s' % e.getMessage())
            failStudent(puid, name, crns, writer, e.getMessage())
    writer.writerow(['EOF'])
    output.close()
    client.stop()
    if puids:
        requestStudentUpdate(puids)

batch = getBatchServer()
if not batch:
    log.error("Batch student scheduling solver is not loaded in.")
else:
    execute(batch)
]]></body>
</script>
</scripts>