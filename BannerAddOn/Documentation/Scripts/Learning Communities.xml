<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE scripts PUBLIC "-//UniTime//DTD University Course Timetabling/EN" "http://www.unitime.org/interface/Script.dtd">

<!--
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 *
 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 -->

<scripts created="March 14, 2016">
<script name="Learning Communities: Course Matrix Import [legacy]" permission="Student Group Edit" engine="python" created="Mon Mar 14 11:28:15 EDT 2016">
  <description><![CDATA[This script creates student groups and student group reservations according to the input file (LC Course Matrix in CSV format).]]></description>
  <parameter name="file" label="Input File" type="file"/>
  <body><![CDATA[import csv
import re
from org.unitime.timetable.model import StudentGroup, StudentGroupReservation, StudentSectioningQueue
from java.util import HashSet
from java.lang import Long

def getGroupCode(name):
    m = re.search('(.+) - (.+)', name)
    if m:
        return m.group(1)
    m = re.search('(.+) \(.+\)', name)
    if m: name = m.group(1)             
    code = []
    for word in name.split(' '):
        if not word: continue
        if word in ["to", "in", "of", "for", "the", "a", "&", "-", "or", "and"]: continue
        m = re.search('([A-Z][A-Z]+)', word)
        if m:
            if len(code) > 0: code.append(' ')
            code.extend(m.group(1))
            code.append(' ')
        elif len(word) <= 4:
            code.extend(word)
        else:
            code.extend(word[0:3])
    return ''.join(code).strip() 

def getGroupName(name):
    m = re.search('(.+) - (.+)', name)
    if m:
        return m.group(2)
    return name
    
def getGroup(name):
    group = hibSession.createQuery("from StudentGroup where groupName = :name and session = :sessionId").setLong("sessionId", session.getUniqueId()).setString("name", getGroupName(name)).setMaxResults(1).uniqueResult();
    if not group:
        log.info("Creating group for name %s" % name)
        group = StudentGroup()
        group.setSession(session)
        group.setGroupAbbreviation(getGroupCode(name));
        group.setGroupName(getGroupName(name));
        group.setUniqueId(hibSession.save(group))
    return group

def addClass(course2classes, group, subject, courseNbr, crn, title):
    clazz = hibSession.createQuery("select c from BannerSection bs inner join bs.bannerSectionToClasses as bstc, Class_ c where bs.session = :sessionId and bs.crn = :crn and bstc.classId = c.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
    course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
    if clazz and course:
        log.debug(clazz.getClassLabelWithTitle(course))
        classes = None
        if course in course2classes:
            classes = course2classes[course]
        else:
            classes = []
            course2classes[course] = classes
        classes.append(clazz)
    else:
        log.error("Class %s %s %d not found." % (subject, courseNbr, crn))
        
def isParent(c1, c2):
    if c2.getParentClass():
        if c1 == c2.getParentClass(): return True
        return isParent(c1, c2.getParentClass())
    return False

def hasChild(clazz, classes):
    for c in classes:
        if isParent(clazz, c): return True
    return False

def createReservations(offerings, group, course2classes):
    for course in course2classes.keys():
        log.info("Checking reservation for %s..." % course.getCourseName())
        reservation = hibSession.createQuery("from StudentGroupReservation where instructionalOffering = :offeringId and group = :groupId").setLong("offeringId", course.getInstructionalOffering().getUniqueId()).setLong("groupId", group.getUniqueId()).uniqueResult()
        if not reservation:
            reservation = StudentGroupReservation()
            reservation.setGroup(group)
            reservation.setInstructionalOffering(course.getInstructionalOffering())
            reservation.setClasses(HashSet())
        else:
            reservation.getClasses().clear()
        classes = course2classes[course]
        for clazz in classes:
            if not hasChild(clazz, classes):
                reservation.getClasses().add(clazz)
                log.debug("add %s" % clazz.getClassLabel(course))
            else:
                log.debug("skip %s" % clazz.getClassLabel(course))
        offerings.add(Long(course.getInstructionalOffering().getUniqueId()))
        hibSession.saveOrUpdate(reservation)

lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')

group = None
header = True
course2classes = None
offerings = HashSet()
for line in lines:
    if not line or not line[2]:
        if group: createReservations(offerings, group, course2classes)
        group = None
        continue
    if header:
        header = False
        if "Learning Community" == line[0]: continue
    if not group and line[0]:
        group = getGroup(line[0])
        course2classes = {}
        print "Group %s - %s" % (group.getGroupAbbreviation(), group.getGroupName())
    if line[2] and line[3] and line[4]:
        subject = line[3].strip()
        courseNbr = line[4].strip()
        title = line[5]
        for extId in line[2].split(';'):
            addClass(course2classes, group, subject, courseNbr, int(extId.strip()), title)
if group: createReservations(offerings, group, course2classes)
if offerings:    
    StudentSectioningQueue.offeringChanged(hibSession, None, session.getUniqueId(), offerings);]]></body>
</script>
<script name="Learning Communities: Course Matrix Import [simplified]" permission="Student Group Edit" engine="python" created="Mon Mar 14 11:22:39 EDT 2016">
  <description><![CDATA[This script creates student groups and student group reservations according to the CSV input file  in one of the following formats:<ol><li>One line per class:<pre>
LC, Name            , Subj, Course, CRN
G1, Learning Group 1, ENGL, 10600 , 12345
  ,                 ,        ,    , 12346
  ,                 , BIOL, 10100 , 22222
G2, Learning Group 2, ENGL, 10600 , 12345
  ,                 ,        ,    , 12347
  ,                 , MATH, 20100 , 12034
</pre></li><li>One line per course:<pre>
LC, Name            , Subj, Course, CRN1 , CRN2 , CRN3 , ...
G1, Learning Group 1, ENGL, 10600 , 12345, 12346
  ,                 , BIOL, 10100 , 22222
G2, Learning Group 2, ENGL, 10600 , 12345, 12347
  ,                 , MATH, 20100 , 12034
</pre></li><li>One line per course, no section-level restrictions:<pre>
LC, Name            , Subj, Course
G1, Learning Group 1, ENGL, 10600R
  ,                 , BIOL, 10100
G2, Learning Group 2, ENGL, 10600R
  ,                 , MATH, 20100
</pre></li></ol>]]></description>
  <parameter name="file" label="Input File" type="file"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import StudentGroup, StudentGroupReservation, StudentSectioningQueue
from java.util import HashSet
from java.lang import Long

def getGroup(abbv, name):
    group = hibSession.createQuery("from StudentGroup where groupAbbreviation = :abbv and session = :sessionId").setLong("sessionId", session.getUniqueId()).setString("abbv", abbv).setMaxResults(1).uniqueResult();
    if not group:
        log.info("Creating group %s - %s" % (abbv, name))
        group = StudentGroup()
        group.setSession(session)
        group.setGroupAbbreviation(abbv);
        group.setGroupName(name);
        group.setUniqueId(hibSession.save(group))
    else:
        log.info("Found group %s - %s" % (group.getGroupAbbreviation(), group.getGroupName()))
    return group

def addClass(course2classes, group, subject, courseNbr, crn, writer):
    clazz = hibSession.createQuery("select c from BannerSection bs inner join bs.bannerSectionToClasses as bstc, Class_ c where bs.session = :sessionId and bs.crn = :crn and bstc.classId = c.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
    course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
    if clazz and course:
        if not course.getSubjectAreaAbbv() == subject or not course.getCourseNbr().startswith(courseNbr):
            log.error("Class %s %s %d is wrong (found %s)." % (subject, courseNbr, crn, course.getCourseNameWithTitle()))
            writer.writerow([group.getGroupAbbreviation(), group.getGroupName(), subject, courseNbr, crn, "Class %s %s %d is wrong (found %s)." % (subject, courseNbr, crn, course.getCourseNameWithTitle())])
            return
        log.debug(clazz.getClassLabelWithTitle(course))
        classes = None
        if course in course2classes:
            classes = course2classes[course]
        else:
            classes = []
            course2classes[course] = classes
        classes.append(clazz)
        writer.writerow([group.getGroupAbbreviation(), group.getGroupName(), subject, courseNbr, crn])
    else:
        log.error("Class %s %s %d not found." % (subject, courseNbr, crn))
        writer.writerow([group.getGroupAbbreviation(), group.getGroupName(), subject, courseNbr, crn, "Class %s %s %d not found." % (subject, courseNbr, crn)])

def addCourse(course2classes, group, subject, courseNbr, writer):
    course = hibSession.createQuery("from CourseOffering co where co.subjectArea.session = :sessionId and co.subjectAreaAbbv = :subject and co.courseNbr = :courseNbr"
                                    ).setLong("sessionId", session.getUniqueId()).setString("subject", subject).setString("courseNbr", courseNbr).setMaxResults(1).uniqueResult()
    if course:
        log.debug(course.getCourseNameWithTitle())
        if course not in course2classes:
            course2classes[course] = []
        writer.writerow([group.getGroupAbbreviation(), group.getGroupName(), subject, courseNbr, None])
    else:
        log.error("Course %s %s not found." % (subject, courseNbr))
        writer.writerow([group.getGroupAbbreviation(), group.getGroupName(), subject, courseNbr, None, "Course %s %s not found." % (subject, courseNbr)])
        
def isParent(c1, c2):
    if c2.getParentClass():
        if c1 == c2.getParentClass(): return True
        return isParent(c1, c2.getParentClass())
    return False

def hasChild(clazz, classes):
    for c in classes:
        if isParent(clazz, c): return True
    return False

def createReservations(offerings, group, course2classes):
    reservations = {}
    for r in hibSession.createQuery("from StudentGroupReservation where group = :groupId").setLong("groupId", group.getUniqueId()).list():
        reservations[r.getInstructionalOffering().getUniqueId()] = r
    for course in course2classes.keys():
        reservation = None
        if course.getInstructionalOffering().getUniqueId() in reservations:
            log.info("Checking reservation for %s (%s)..." % (course.getCourseName(), group.getGroupAbbreviation()))
            reservation = reservations.pop(course.getInstructionalOffering().getUniqueId())
            reservation.getClasses().clear()
        else:
            log.info("Creating reservation for %s (%s)..." % (course.getCourseName(), group.getGroupAbbreviation()))
            reservation = StudentGroupReservation()
            reservation.setGroup(group)
            reservation.setInstructionalOffering(course.getInstructionalOffering())
            reservation.setClasses(HashSet())
            reservation.getInstructionalOffering().getReservations().add(reservation)
        classes = course2classes[course]
        for clazz in classes:
            if not hasChild(clazz, classes):
                reservation.getClasses().add(clazz)
                log.debug("add %s" % clazz.getClassLabel(course))
            else:
                log.debug("skip %s" % clazz.getClassLabel(course))
        hibSession.saveOrUpdate(reservation)
        offerings.add(Long(course.getInstructionalOffering().getUniqueId()))
    for r in reservations.values():
        log.info("Deleting reservation for %s (%s)..." % (r.getInstructionalOffering().getCourseName(), group.getGroupAbbreviation()))
        r.getInstructionalOffering().getReservations().remove(r)
        offerings.add(Long(r.getInstructionalOffering().getUniqueId()))
        hibSession.delete(r)
    hibSession.flush()

lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')
output = open(log.createOutput('lc-import-results','csv').getAbsolutePath(), 'w')
writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
writer.writerow(['LC','Name','Subject','Course','CRN','Error'])

groups = {}
header = True
course2classes = {}
last = [None, None, None, None]
for line in lines:
    if not line:
        last = [None, None, None, None]
        continue
    
    lcAbbv = line[0].strip()
    lcName = line[1].strip()
    subject = line[2].strip()
    courseNbr = line[3].strip()
    crns = []
    for crn in line[4:]:
        if crn.strip(): crns.append(crn.strip())
    if header:
        header = False
        if "LC" == lcAbbv: continue
    
    if not lcAbbv: lcAbbv = last[0]
    if not lcName: lcName = last[1]
    if not subject: subject = last[2]
    if not courseNbr: courseNbr = last[3]
    last = [lcAbbv, lcName, subject, courseNbr]
    
    if lcAbbv not in groups:
        groups[lcAbbv] = getGroup(lcAbbv, lcName)
        course2classes[lcAbbv] = {}
    
    if crns:
        for crn in crns:
            addClass(course2classes[lcAbbv], groups[lcAbbv], subject, courseNbr, int(crn), writer)
    else:
        addCourse(course2classes[lcAbbv], groups[lcAbbv], subject, courseNbr, writer)
writer.writerow(['EOF'])
output.close()

offerings = HashSet()
for lcAbbv in groups.keys():
    createReservations(offerings, groups[lcAbbv], course2classes[lcAbbv])

if offerings:    
    StudentSectioningQueue.offeringChanged(hibSession, None, session.getUniqueId(), offerings);]]></body>
</script>
<script name="Learning Communities: Student Import" permission="Student Group Edit" engine="python" created="Mon Mar 14 12:34:24 EDT 2016">
  <description><![CDATA[This script imports students of one or more student groups according to the input CSV file in the following formats:
<ol><li>One line per student:<pre>
LC, PUID
G1, 752297072
  , 670857846
  , 110163506
  , 685497415
G2, 565607184
  , 288674378
  , 845738199
  , 139074464
</pre></li><li>One line per group:<pre>
LC, PUID1    , PUID2    , PUID3    , ...
G1, 752297072, 670857846, 110163506, 685497415
G2, 565607184, 288674378, 845738199, 139074464
</pre></li></ol>]]></description>
  <parameter name="updateSpace" label="Update Reserved Space" type="boolean" default="true"/>
  <parameter name="file" label="Input File" type="file"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import StudentSectioningQueue
from java.util import HashSet
from java.lang import Long

def lookupStudent(puid):
    student = hibSession.createQuery("from Student where session = :sessionId and externalUniqueId = :puid").setLong("sessionId", session.getUniqueId()).setString("puid", puid).setMaxResults(1).uniqueResult()
    if not student:
        log.warn("Student %s not found." % puid)
    else:
        log.debug("%s (%s)" % (student.getName("last-first-middle"), puid))
    return student

def enroll(students, lcAbbv, puids, writer):
    group = hibSession.createQuery("from StudentGroup where (groupAbbreviation = :abbv or groupName = :abbv) and session = :sessionId").setLong("sessionId", session.getUniqueId()).setString("abbv", lcAbbv).setMaxResults(1).uniqueResult();
    if not group:
        log.error("Student group %s does not exist." % lcAbbv)
        for puid in puids:
            student = lookupStudent(puid.lstrip("0"))
            if student:
                writer.writerow([lcAbbv, puid, student.getName("last-first-middle"), student.getEmail(), "Student group %s does not exist." % lcAbbv])
            else:
                writer.writerow([lcAbbv, puid, None, None, "Student group %s does not exist.\nStudent %s not found." % (lcAbbv, puid)])
        return
    log.info("%s - %s" % (group.getGroupAbbreviation(), group.getGroupName()))
    group.getStudents().clear()
    for puid in puids:
        student = lookupStudent(puid.lstrip("0"))
        if student:
            group.getStudents().add(student)
            students.add(Long(student.getUniqueId()))
            writer.writerow([group.getGroupAbbreviation(), puid, student.getName("last-first-middle"), student.getEmail()])
        else:
            writer.writerow([group.getGroupAbbreviation(), puid, None, None, "Student %s not found." % puid])
    hibSession.saveOrUpdate(group)
    if updateSpace:
        for r in hibSession.createQuery("from StudentGroupReservation where group = :groupId").setLong("groupId", group.getUniqueId()).list():
            r.setLimit(len(puids))
            hibSession.saveOrUpdate(r)

lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')

groups = {}
header = True
last = None
students = HashSet()
for line in lines:
    if not line:
        last = None
        continue
    
    lc = line[0].strip()
    if header:
        header = False
        if "LC" == lc: continue
    
    if not lc: lc = last
    last = lc
    if lc not in groups: groups[lc] = []
    for puid in line[1:]:
        if puid.strip(): groups[lc].append(puid.strip())

output = open(log.createOutput('lc-enrollment-results','csv').getAbsolutePath(), 'w')
writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
writer.writerow(['LC','PUID','Name','Email','Error'])
for lc in groups.keys():
    enroll(students, lc, groups[lc], writer)
writer.writerow(['EOF'])
output.close()

if students:
    StudentSectioningQueue.studentChanged(hibSession, None, session.getUniqueId(), students)]]></body>
</script>
<script name="Learning Communities: Create Course Demands" permission="Student Group Edit" engine="python" created="Fri Mar 18 12:58:06 EDT 2016">
  <description><![CDATA[<p style='max-width:800px'>This script makes sure that students which are enrolled into the existing student groups also request the appropriate courses. The script is using either the existing student group reservations <b><u>or</u></b> the provided LC course matrix to decide which courses students of a learning group should take.</p>
<p style='max-width:800px'>The <b>LC Course Matrix</b> file is optional. If provided, it has to be in the same format as for the <u>Learning Communities: Course Matrix Import [simplified]</u> script. If it is not provided, the controlling courses of the existing student group reservations are used instead.</p>]]></description>
  <parameter name="statusRef" label="Status" type="reference(StudentSectioningStatus)" default="LC"/>
  <parameter name="file" label="LC Course Matrix" type="file"/>
  <parameter name="clear" label="Clear Existing Demands" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import CourseDemand, CourseRequest, StudentSectioningStatus, StudentSectioningQueue
from java.util import Date, HashSet
from java.lang import Long
from __builtin__ import True

def addClass(course2classes, subject, courseNbr, crn):
    clazz = hibSession.createQuery("select c from BannerSection bs inner join bs.bannerSectionToClasses as bstc, Class_ c where bs.session = :sessionId and bs.crn = :crn and bstc.classId = c.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
    course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
    if clazz and course:
        if not course.getSubjectAreaAbbv() == subject or not course.getCourseNbr().startswith(courseNbr):
            log.error("Class %s %s %d is wrong (found %s)." % (subject, courseNbr, crn, course.getCourseNameWithTitle()))
            return
        classes = None
        if course in course2classes:
            classes = course2classes[course]
        else:
            classes = []
            course2classes[course] = classes
        classes.append(clazz)
    else:
        log.error("Class %s %s %d not found." % (subject, courseNbr, crn))

def addCourse(course2classes, subject, courseNbr):
    course = hibSession.createQuery("from CourseOffering co where co.subjectArea.session = :sessionId and co.subjectAreaAbbv = :subject and co.courseNbr = :courseNbr"
                                    ).setLong("sessionId", session.getUniqueId()).setString("subject", subject).setString("courseNbr", courseNbr).setMaxResults(1).uniqueResult()
    if course:
        if course not in course2classes:
            course2classes[course] = []
    else:
        log.error("Course %s %s not found." % (subject, courseNbr))

groups = hibSession.createQuery("from StudentGroup where session = :sid").setLong("sid", session.getUniqueId()).list()

status = None
if statusRef:
    status = StudentSectioningStatus.getStatus(statusRef, session.getUniqueId(), hibSession)
ts = Date()

students = HashSet()

if status:
   for student in hibSession.createQuery(
        "from Student where sectioningStatus.uniqueId = :statusId and session = :sessionId"
        ).setLong("sessionId", session.getUniqueId()).setLong("statusId", status.getUniqueId()).list():
       student.setSectioningStatus(None);
       students.add(Long(student.getUniqueId()))
       hibSession.saveOrUpdate(student);

course2classes = {}
if file:
    lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')
    header = True
    last = [None, None, None, None]
    for line in lines:
        if not line:
            last = [None, None, None, None]
            continue
        lcAbbv = line[0].strip()
        lcName = line[1].strip()
        subject = line[2].strip()
        courseNbr = line[3].strip()
        crns = []
        for crn in line[4:]:
            if crn.strip(): crns.append(crn.strip())
        if header:
            header = False
            if "LC" == lcAbbv: continue
    
        if not lcAbbv: lcAbbv = last[0]
        if not lcName: lcName = last[1]
        if not subject: subject = last[2]
        if not courseNbr: courseNbr = last[3]
        last = [lcAbbv, lcName, subject, courseNbr]
    
        if lcAbbv not in course2classes:
            course2classes[lcAbbv] = {}

        if crns:
            for crn in crns:
                addClass(course2classes[lcAbbv], subject, courseNbr, int(crn))
        else:
            addCourse(course2classes[lcAbbv], subject, courseNbr)
else:
    log.warn('LC Course Matrix file was not provided, using controlling courses of the appropriate student group reservations instead')

for group in groups:
    if course2classes and group.getGroupAbbreviation() not in course2classes: continue
    courses = None
    if group.getGroupAbbreviation() in course2classes:
        courses = course2classes[group.getGroupAbbreviation()].keys()
    else:
        reservations = hibSession.createQuery("from StudentGroupReservation where group = :gid order by uniqueId").setLong("gid", group.getUniqueId()).list()
        courses = map(lambda r: r.getInstructionalOffering().getControllingCourseOffering(), reservations)
    log.info("%s: %s" % (group.getGroupAbbreviation(), ', '.join(map(lambda course: course.getCourseName(), courses))))
    for student in group.students:
        log.info("%s %s" % (student.getExternalUniqueId(), student.getName("last-first-middle")))
        if status: student.setSectioningStatus(status);
        if clear:
            for cd in student.getCourseDemands():
                if cd.getFreeTime(): hibSession.delete(cd.getFreeTime())
                for cr in cd.getCourseRequests(): hibSession.delete(cr)
                hibSession.delete(cd)
            student.getCourseDemands().clear()
            for enrl in student.getClassEnrollments(): hibSession.delete(enrl)
            student.getClassEnrollments().clear()
        priority = 0
        for cd in student.getCourseDemands():
            if priority <= cd.getPriority() and not cd.isAlternative(): priority = cd.getPriority() + 1
        for course in courses:
            included = False
            for cd in student.getCourseDemands():
                for cr in cd.getCourseRequests():
                    if cr.getCourseOffering() == course:
                        included = True
            if included: continue
            log.debug(course.getCourseNameWithTitle())
            cd = CourseDemand()
            cd.setCourseRequests(HashSet())
            cd.setStudent(student)
            student.getCourseDemands().add(cd)
            cd.setAlternative(False)
            cd.setPriority(priority)
            priority = priority + 1
            cd.setWaitlist(False)
            cd.setTimestamp(ts)
            cr = CourseRequest()
            cd.getCourseRequests().add(cr)
            cr.setCourseDemand(cd)
            cr.setAllowOverlap(False)
            cr.setCredit(0)
            cr.setOrder(0)
            cr.setCourseOffering(course)
        students.add(Long(student.getUniqueId()))
        hibSession.saveOrUpdate(student);
        
if students:
    StudentSectioningQueue.studentChanged(hibSession, None, session.getUniqueId(), students)]]></body>
</script>
</scripts>